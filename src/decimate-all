#!/usr/bin/perl -w

########################################################################
#
#  utility for decimating an entire dataset
#


use strict;

use FindBin;
use lib $FindBin::Bin;
use lib "$FindBin::Bin/../bin";

use DecimateAll;
use Getopt::Long qw(:config bundling auto_abbrev);


########################################################################
#
#  process command line
#

my $datadir = 'data';
my $jobs;
my $start = 0;

my $usage = <<EOT;
Usage: $0 [OPTION...] <sparsity>

  --datadir=DIR  find run suite in DIR (default "data")
  --jobs=COUNT   use COUNT simultaneous jobs (default is CPU count - 1)
  --start=NUM    start with report NUM (default 0)
EOT

sub help () {
  print $usage;
  exit 0;
}

my $understood = GetOptions('jobs=i' => \$jobs,
			    'datadir=s' => \$datadir,
			    'start=i' => \$start,
			    'help|?' => \&help);

die $usage unless $understood && @ARGV == 1;
my ($sparsity) = @ARGV;

$jobs = DecimateAll->cpu_count - 1 unless $jobs;
$jobs = 1 if $jobs < 1;


########################################################################
#
#  decimate the reports
#

# sanity check
my $decimator = "$FindBin::Bin/decimate-sparse";
-x $decimator or die "$decimator is not executable\n";


# how many runs to process?
my $numRuns = new FileHandle "$datadir/stamp-labels" or die "cannot read $datadir/stamp-labels: $!\n";
$numRuns = <$numRuns>;
chomp $numRuns;


# decimate all reports
my $runner = new DecimateAll(jobs => $jobs,
			     datadir => $datadir,
			     sparsity => $sparsity,
			     decimator => $decimator);
$runner->run_tasks(0 .. $numRuns - 1);
