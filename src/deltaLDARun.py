#!/s/python-2.7.1/bin/python
# -*- python -*-

###############################################################################

import optparse
import sys

import numpy
import scipy
import scipy.sparse
import scipy.io

from deltaLDA import deltaLDA
from itertools import count
from collections import defaultdict
from os.path import dirname, join

def runDeltaLDA(data, numsamp, randseed, binarizedOnly):
    """Run the deltaLDA analysis on 'data' based on data generated from
    runsinfo.mat and return the result.

    ARGUMENTS:
    * numsamp - specifies how many samples to take from the Gibbs sampler
    * randseed - is used to initialize the Gibbs sampler random number generator

    """
    result = {}
    if not binarizedOnly:
        (result['phi'], result['theta'], result['sample']) = deltaLDA(data['docs'],
                                                                      data['alpha'],
                                                                      data['beta'],
                                                                      numsamp,
                                                                      randseed,
                                                                      f=data['Fvector'])

    (result['phi_bin'], result['theta_bin'], result['sample_bin']) = deltaLDA(data['bindocs'],
                                                                  data['alpha'],
                                                                  data['beta'],
                                                                  numsamp,
                                                                  randseed,
                                                                  f=data['Fvector'])

    def normalize(array, axis):
        """Normalize the entries of the array based onthe axis specified
        """
        array2 = numpy.sum(array, axis) #sum it along axis
        # TODO: make this applicable for more than 2D arrays
        array2 = array2.reshape((array2.shape[0], 1))
        array2 = array2.repeat(array.shape[1], axis=1)
        return numpy.divide(array, array2)

    def getprzAndprzw(theta, phi):
        prz = numpy.sum(theta, 0)
        prz = prz.reshape((prz.shape[0], 1))
        prz_w = numpy.multiply(phi, prz.repeat(phi.shape[1],
                                               axis=1)).transpose()
        return prz/numpy.sum(prz), normalize(prz_w, 1)

    if not binarizedOnly:
        result['prz'], result['prz_w'] = getprzAndprzw(result['theta'], result['phi'])
    result['prz_bin'], result['prz_w_bin'] = getprzAndprzw(result['theta_bin'], result['phi_bin'])

    return result



def processMatFile(source, usageTopics, bugTopics, binarizedOnly):
    """
    Process the runsinfo.mat file generated by the cbiexp/src/analysis-rules.mk
    script into a format conducive to being able to run deltaLDA.

    ARGUMENTS:
    * source - location of the runsinfo.mat file
    * usageTopics - number of usage topics
    * bugTopics - number of bug topics
    """

    def buildDocList(loc, count=1, docs=[], bindocs=[]):
        [docnum, word] = loc
        try:
            doc = docs[docnum]
            bindoc = bindocs[docnum]
        except IndexError:
            if docnum > len(docs):
                raise NameError('You skipped a doc!')
            else:
                docs.append([])
                doc = docs[docnum]
                bindocs.append([])
                bindoc = bindocs[docnum]

        if not binarizedOnly:
            for i in xrange(count):
                doc.append(word)
        bindoc.append(word)

    def convertXtoDocList(X):
        docs = []
        bindocs = []
        xT = X.transpose()
        locsT = numpy.transpose(numpy.nonzero(xT))
        for locT in locsT:
            if len(locT.shape) == 2:
                locT = locT[0]
            [col, row] = locT
            count = int(xT[col, row])
            buildDocList(locT, count, docs, bindocs)
        return docs, bindocs

    data={}

    runs = scipy.io.loadmat(source, struct_as_record=True)
    Data = runs['Data'][0][0]
    X = Data['X']
    numwords, numdocs = X.shape
    numtopics = usageTopics + bugTopics
    data['beta'] = numpy.ones((numtopics, numwords))
    alpha_succ = numpy.concatenate((numpy.ones((1, usageTopics)), numpy.zeros((1,
                                                                               bugTopics))),
                                   1)
    alpha_fail = numpy.ones((1, numtopics))
    data['alpha'] = 0.1 * numpy.concatenate((alpha_succ, alpha_fail))

    x = None
    if isinstance(X, numpy.ndarray):
        if X.shape == (0, 0):
            raise myUtils.myError("Whoops X matrix is empty, see if preds.txt is empty too!", source.split('/')[-2])
        x = X
    else: # previous matlab files were saved in sparse format
        x = X.todense()

    data['docs'], data['bindocs'] = convertXtoDocList(x)

    data['docToRunID'] = {}
    for docnum in xrange(numdocs):
        data['docToRunID'][docnum] = Data['Indices'][docnum, 0]

    data['Fvector'] = Data['Fvector'][:, 0].tolist()
    data['Svector'] = Data['Svector'][:, 0].tolist()
    data['Causes'] = Data['Causes'][:, 0].tolist()

    data['inputfile'] = str(Data['inputfile'][0])
    data['fraction'] = Data['fraction'][0, 0]

    return data



def deltaLDARun(runsinfo, optargs={}):
    """Convert the runsinfo.mat file and run deltaLDA on it.

    ARGUMENTS:
    * runsinfo - name of the 'runsinfo.mat' file
    * optargs - dictionary containing 'usageTopics', 'bugTopics', 'numsamp',
    'randseed'

    RETURNS:
    deltaLDAResults
    """

    usageTopics = optargs.setdefault('usageTopics', 1)
    bugTopics = optargs.setdefault('bugTopics', 1)
    # numsamp specifies how many samples to take from the Gibbs sampler
    numsamp = optargs.setdefault('numsamp', 500)
    # randseed is used to initialize the Gibbs sampler random number generator
    randseed = optargs.setdefault('randseed', 194582)
    binarizedOnly = optargs.setdefault('binarizedOnly', False)

    processedMat = processMatFile(runsinfo, usageTopics, bugTopics, binarizedOnly)
    deltaLDAResults = runDeltaLDA(processedMat, numsamp, randseed, binarizedOnly)

    deltaLDAResults['bugTopics'] = bugTopics
    deltaLDAResults['usageTopics'] = usageTopics

    return deltaLDAResults




def main(argv=None):
    """ 
    Run the Delta-LDA algorithm. This assumes that you already have the
    'runsinfo.mat' file from having run the appropriate analysis in
    sliver/cbiAnalyze.py.
    """

    if argv is None:
        argv = sys.argv

    parser = optparse.OptionParser(usage='%prog [options] runsinfo.mat')
    parser.add_option('-u', '--usageTopics', action='store', default=1, type='int',
                      help = 'number of usage topics')

    parser.add_option('-b', '--bugTopics', action='store', default=1, type='int',
                      help = 'number of bugtopics')

    parser.add_option('-n', '--numsamp', action='store', default=500, type='int',
                      help = 'number of samples to take from the Gibbs sampler')

    parser.add_option('-r', '--randseed', action='store', default=194582, type='int',
                      help = 'seed used to initialize the Gibbs sampler random number generator')

    parser.add_option('-B', '--binarized-only', action='store_true', default=False,
                      help = 'run deltaLDA on binarized documents.  Use when documents are large')

    options, args = parser.parse_args(argv[1:])
    if len(args) !=1:
        parser.error('wrong number of positional arguments')

    optargs = {
        'usageTopics': options.usageTopics,
        'bugTopics': options.bugTopics,
        'numsamp': options.numsamp,
        'randseed': options.randseed,
        'binarizedOnly': options.binarized_only,
        }

    deltaLDAResults = deltaLDARun(args[0], optargs)

    if not options.binarized_only:
        deltaLDAResults.pop('sample')
    deltaLDAResults.pop('sample_bin')
    outfile = join(dirname(args[0]), 'deltaLDAResults.mat')
    scipy.io.savemat(outfile, deltaLDAResults)

    return deltaLDAResults

###############################################################################
if __name__ == '__main__':
    main()
    sys.exit()
