% -*- TeX-master: "master" -*-

\section{Related Work}
\label{sec-rw}
Daikon \cite{ErnstPGMPTX2006} detects invariants in a program by observing values computed by it over multiple program runs.  Invariants are predicates generated by using operators like sum, max, etc. to combine program variables and collection (e.g., array) objects.  Daikon is intended for many uses beyond bug isolation, and so it monitors a much larger set of predicates than CBI, which makes complex predicate generation more infeasible; despite this Dodoo et al.\ \cite{ErnstDRAFT} have successfully extended the work to generate implications from the simpler, measured predicates.  There are no known attempts to use Daikon under sparse sampling conditions.

SOBER \cite{1081753} is a statistical debugging tool similar to CBI.  Where CBI considers only whether a predicate was ever observed true during an execution, SOBER estimates the likelihood of it being true at any given evaluation.  When tested on the Siemens suite with full sampling this additional information resulted in better identification of bug predictors than traditional CBI analysis \cite{1081753}.  There are no known experiments using SOBER under sparse sampling conditions.  Since SOBER mimics CBI's structure, collecting data from deployed executions is possible, but SOBER analysis requires many more bits of data than CBI, increasing the burden on end users.

\subsection{Daikon and Complex Predicates}
\label{sec-daikon}
The system of generating complex predicates described in \cite{ErnstDRAFT} is very different from ours.  Dodoo et al.\ alternate clustering and invariant detection to find invariant implications over a set of program runs.  The initial clustering is performed using the k-means algorithm \cite{jain99data}, with program runs represented as normalized vectors of scalar variable values.  Since CBI represents run information as bit-vectors this technique can be applied essentially unchanged.

Daikon's implication generation extends the thoroughness of its invariant detection.  CBI's focus is detection of bug predictors, which under sparse sampling conditions can rarely be identified as invariant.  Additionally the fact that an implication exists is of questionable value in this project; the implication revealed in \autoref{sec-ccrypt} is an interesting and potentially useful side-effect of our analysis, but only because it involves identified bug predictors.  The approach described in this paper is better suited to the goals and analysis techniques of CBI.

DIDUCE \cite{581377} is inspired by Daikon, and detects invariant bits of numerical program values.  When operating in checking mode DIDUCE notifies the user the first time an inferred invariant is broken; the invariant is then relaxed to allow the new value.  Training mode functions the same way except that invariants are relaxed silently.  Both Daikon and CBI cleanly separate data collection and evaluation, whereas DIDUCE tightly couples the two.  Because of this coupling neither our approach to complex predicate generation nor Daikon's is easily applicable to DIDUCE's framework.

\subsection{SOBER and Complex Predicates}
CBI data is stored as a bit-vector for each program run, with each pair of bits (observed and true) representing a simple predicate.  SOBER data is a probability vector, with each value representing the estimated chance of a simple predicate being true when observed.  The similarity in collected data means that similar techniques for complex predicate generation are applicable.  The three-valued logic described in \autoref{sec-tvl} could be replaced with joint-probability when generating conjunctions; De Morgan's law can be applied to generate disjunctions.  Our usefulness metrics can be used on the resulting data.

Complex predicate generation removes a key advantage of SOBER - predicate scores result directly from the number of actual predicate evaluations.  Complex predicates generated by this technique are never truly evaluated, so their probability values would have little connection to actual program execution.  Whether this would affect their usefulness is unknown.
