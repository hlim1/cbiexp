\section{Introduction}

The Cooperative Bug Isolation (CBI) Project~\cite{Liblit:2004:CBI} finds bugs in programs by analyzing reports collected from software executing in the hands of end users.  To use CBI, the software must be compiled with an instrumenting compiler that inserts snippets that evaluate boolean expressions (called predicates) at various program points.  Predicates are designed to capture program behaviors such as results of function calls, directions of branches or values of variables.  At the end of each execution, the instrumented program generates a report that contains the number of times each predicate was true.  Statistical debugging (~\cite{Liblit:2005:SSBI} and ~\cite{Zheng:2006:SDSIMB}) is used to analyze these reports and find predicates that are predictive of failure.  These predicates are then ranked and presented to the developer.

CBI gathers execution reports by using valuable CPU cycles at end user machines.  It is essential to make those cycles worthwhile by extracting every bit of useful information from them.  However the current statistical analysis algorithms (~\cite{Liblit:2005:SSBI} and ~\cite{Zheng:2006:SDSIMB}) consider predicates in isolation from one another.  They overlook potentially useful relations between predicates.  Predicates are expressions involving program variables at different program points and hence may be related by control and data dependences.  We propose to capture these relations by building $complex$ predicates from the set of currently instrumented predicates (which we refer to as simple predicates).  Since predicates are boolean expressions, they are combined using logical operators (such as $and$ and $or$).  We construct complex predicates and include them in the input to the statistical analysis algorithms.

There are two approaches to combine predicates using logical operators:
\begin{enumerate}
\item Explicitly monitor the complex predicate by changing the output of the instrumenting compiler
\item Estimate the value of the complex predicate from the values of its components.
\end{enumerate}

The first approach will yield a precise value but needs significant modifications to existing infrastructure.  The second approach will be less precise (as described later) but requires only few modifications to existing infrastructure (and none to the instrumenting compiler).  In this project, we implement the second approach, that will serve as a proof of concept for complex predicates, as well as a justification for a future attempt at incorporating them into the compiler.

The remainder of this report is organized as follows.  Section ~\ref{sec-bground} introduces CBI and explains the motivation for complex predicates.  Section ~\ref{sec-complex-preds} gives a precise definition of complex predicates and discusses the trade-offs in our implementation.  Section ~\ref{sec-metrics} describes two metrics to evaluate the usefulness of a complex predicate.  Section ~\ref{sec-qual} describes two case studies that demonstrate the usefulness of complex predicates.  

Section ~\ref{sec-quant} presents the results of experiments conducted on a large suite of test programs.  Section ~\ref{sec-sampling} discusses the effect of sparse random sampling on complex predicates.  Sparse random sampling is a technique used in CBI to reduce the runtime overhead on the instrumented programs.  Section ~\ref{sec-rw} discusses some related work and section ~\ref{sec-conc} concludes.
