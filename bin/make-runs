#!/usr/bin/perl -w
#-*- cperl -*-

use strict;

use FindBin;
use lib $FindBin::Bin;

use Cwd;
use File::Path;
use File::stat;
use FileHandle;
use Getopt::Long qw(:config bundling auto_abbrev);

my $RunsPerSubdirectory = 10000;


########################################################################
#
#  sanity check
#

my $cwd = getcwd;
my $run_once = 'bin/run-once';
my $label_once = 'bin/label-once';

unless (-x $run_once && -x $label_once) {
    warn "Error: current directory is not set up for scripted CBI runs.\n\n";
    warn "  $run_once script is missing or not executable\n" unless -x $run_once;
    warn "  $label_once script is missing or not executable\n" unless -x $label_once;
    exit 2;
}


########################################################################
#
#  process command line
#

my $jobs;
my $datadir = 'data';
my $start = 0;

my $usage = <<EOT;
Usage: $0 [OPTION...] <num-runs>

  --datadir=DIR  store run suite in DIR (default "data")
  --jobs=COUNT   use COUNT simultaneous jobs (default is CPU count - 1)
  --start=NUM    assume that runs 0 through NUM - 1 have already been done
EOT

sub help () {
  print $usage;
  exit 0;
}

my $understood = GetOptions('jobs=i' => \$jobs,
			    'datadir=s' => \$datadir,
			    'start=i' => \$start,
			    'help|?' => \&help);

die $usage unless $understood && @ARGV == 1;


unless ($jobs) {
    $jobs = 0;
    my $cpuinfo = new FileHandle '/proc/cpuinfo';
    while (<$cpuinfo>) {
	++$jobs if /^processor\t/;
    }
    --$jobs;
}

$jobs = 1 if $jobs < 1;


my ($num_runs) = @ARGV;


########################################################################
#
#  prepare for runs
#

# create data storage area
-d $datadir or mkdir $datadir or die "cannot mkdir $datadir: $!\n";

# perform any other setup work needed before the runs begin
my $prep = "bin/prepare-runs";
if (-x $prep) {
    (system { $prep } $prep) == 0 or die "cannot run $prep: $!\n";
}


########################################################################
#
#  timestamp checking
#


{
    my $label_once_mtime = (stat "$cwd/$label_once")->mtime;

    sub need_label ($$) {
	my $label = stat shift;
	return 1 unless $label;
	return 1 if $label_once_mtime > $label->mtime;

	my $stamp = stat shift;
	return 1 unless $stamp;

	return $stamp->mtime > $label->mtime;
    }
}


########################################################################
#
#  perform all runs
#

my $error = 0;
my $updated = 0;
my $children = 0;


sub reap () {
    wait;
    $error = 1 if $?;
    --$children;
}


foreach my $run_id ($start .. $num_runs - 1) {
    if (-e 'orderly-shutdown') {
	$error = 1;
	last;
    }

    my $subdir = int($run_id / $RunsPerSubdirectory);
    my $rundir = "$datadir/$subdir/$run_id";
    my $stamp_file = "$rundir/stamp";
    my $label_file = "$rundir/label";
    next unless need_label $label_file, $stamp_file;

    # wait for an available slot
    reap while $children >= $jobs;
    last if $error;

    # use the available slot
    my $pid = fork;
    die "cannot fork: $!\n" unless defined $pid;

    if ($pid == 0) {
	if (-e 'stamp') {
	    # already ran; just needs relabeling
	    chdir $rundir;
	} else {
	    # prepare a fresh run directory
	    print "run $run_id: start\n";
	    rmtree $rundir;
	    mkpath $rundir;
	    chdir $rundir;

	    # run the application
	    system "$cwd/$run_once", $run_id;
	    exit 1 if $?;

	    # record that the run completed
	    new FileHandle 'stamp', 'w'
		or die "cannot update stamp: $!\n";
	    print "run $run_id: done\n";
	}

	# label the outcome
	print "run $run_id: label\n";
	open STDOUT, '>', 'label' or die "cannot write label: $!\n";
	system "$cwd/$label_once", $run_id;
	if ($?) {
	    unlink 'label';
	    exit 1;
	} else {
	    exit 0;
	}

    } else {
	# update slot count
	++$children;

	# remember that some work was done
	$updated = 1;
    }
}


# finish up any remaining jobs
reap while $children;
exit 1 if $error;

if ($updated) {
    my $filename = "$datadir/stamp-labels";
    my $stamp = new FileHandle $filename, 'w' or die "cannot write $filename: $!\n";
    $stamp->print("$num_runs\n");
}

exit 0;
