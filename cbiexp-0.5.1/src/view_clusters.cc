#include <argp.h>
#include <cassert>
#include <cstdio>
#include <fstream>
#include <iostream>
#include <iterator>
#include "NumRuns.h"
#include "RunBugs.h"
#include "RunsDirectory.h"
#include "classify_runs.h"
#include "fopen.h"

using namespace std;

const unsigned K = 5;
static vector<unsigned> group_sizes;
static vector<RunList> clusters;

void read_clusters ()
{
  double dist;
  unsigned n;
  clusters.resize(K);
  group_sizes.resize(K);

  FILE * fp = fopenRead("kmeans_groups.txt");
  assert(fp);
  int got = fscanf(fp, "distance: %lg\n", &dist);
  assert(got == 1);
  for (unsigned k = 0; k < K; k++) {
    got = fscanf(fp, "%u ", &n);
    assert(got == 1);
    group_sizes[k] = n;
  }

  for (unsigned r = 0; r < NumRuns::end; r++) {
    got = fscanf(fp, "%u ", &n);
    assert(got == 1);
    assert(n < K);
    if (is_frun[r])
      clusters[n].push_back(r);
  }

  for (unsigned k = 0; k < K; k++) 
    assert(clusters[k].size() == group_sizes[k]);

  fclose(fp);
}

////////////////////////////////////////////////////////////////////////
//
//  Command line processing
//

static void process_cmdline(int argc, char **argv)
{
    static const argp_child children[] = {
        { &NumRuns::argp, 0, 0, 0 },
        { &RunsDirectory::argp, 0, 0, 0 },
        { 0, 0, 0, 0 }
    };

    static const argp argp = {
        0, 0, 0, 0, children, 0, 0
    };

    argp_parse(&argp, argc, argv, 0, 0, 0);
};

////////////////////////////////////////////////////////////////
//
// The main event
//

int main (int argc, char** argv)
{
  process_cmdline (argc, argv);
  classify_runs();

  RunBugs::read_runbugs();

  read_clusters();

  bool skip_bug[] = { 0, 0, 0, 0, 0, 0, 0, 1, 0, 1 };
  RunBugs::BugVec bugs;
  ofstream ofp ("kmeans_clusters.txt");
  ofstream texfp ("kmeans_clusters.tex");
  texfp << "%% File kmeans_clusters.tex, generated by view_clusters.cc" << endl;
  for (unsigned k = 0; k < K; k++) {
    RunBugs::bug_hist(bugs, clusters[k]);
    ofp << "Cluster " << k << " (" << group_sizes[k] << " runs): ";
    copy(bugs.begin(), bugs.end(), ostream_iterator<unsigned>(ofp, "\t"));
    ofp << endl;

    texfp << k+1 << " & " << group_sizes[k] << " & ";
    unsigned i = 0;
    if (! skip_bug[i])
      texfp << bugs[i++];
    for (; i < bugs.size(); ++i) {
      if (!skip_bug[i])
        texfp << " & " << bugs[i];
    }
    texfp << " \\\\" << endl;
  }
  ofp.close();
  texfp.close();

  return (0);
}
